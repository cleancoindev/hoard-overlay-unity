<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Unity Overlay Toolkit: ~_ArmModels Arm Models</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Unity Overlay Toolkit
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">~_ArmModels Arm Models </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The com.unity.xr.legacyinputhelpers package contains three arm models. These are:</p><ul>
<li><a href="../../#Base-Arm-Model">Base Arm Model</a></li>
<li><a href="../../#Swing-Arm-Model">Swing Arm Model</a></li>
<li><a href="../../#Transition-Arm-Model">Transition Arm Model</a></li>
</ul>
<p>These arm models are based on the arm models from the Google daydream package. The original code can be found <a href="https://developers.google.com/vr/develop/unity/get-started-android">here</a>.</p>
<h1>Using the Arm Models</h1>
<p>The arm model pose providers are intended to be used as a pose provider plugin to a tracked pose driver.</p>
<p>Pose provider plugins are used to allow custom logic to be performed while still gaining the update and transform application utility of the tracked pose driver. For the arm models,we read rotation and acceleration data from the controller pose node, the Head position from the Head node, and calculate a position in session space based on a mathematical arm model.</p>
<p>The following image shows how to use the arm model pose provider with a tracked pose driver:</p>
<p><img src="../../images/ArmModelImages/TrackedPoseDriverArmModelExample.png" alt="Arm Model TPD Examples" class="inline"/></p>
<p>The above image shows that the arm model monobehaviour has been linked to the use pose provider field of the tracked pose driver</p>
<p>The following section outlines the parameters that are found on the inspector of the arm model.</p>
<h2>Base Arm Model</h2>
<p>This section outlines how to configure and use the Base Arm Model The base arm model can be used for most situations that require pointing or throwing.</p>
<p>The image below shows the base arm model component:</p>
<p><img src="../../images/ArmModelImages/armmodelbase.png" alt="Base Arm Model" class="inline"/></p>
<p>The following table details the Arm Model inspector controls:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Control Name  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Input Pose Source  </td><td class="markdownTableBodyNone">The Input pose source defines which XR Node will be used as controller tracking input source. The pose data, and gyro/angular acceleration data for this XR Node will be used to drive the arm model calculations.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Head Position Source  </td><td class="markdownTableBodyNone">The head position source defines which XR Node will be used to drive the Head Position when calculating the arm model.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Arm Extension Offset  </td><td class="markdownTableBodyNone">Offset applied to the elbow position as the controller is rotated upwards.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Elbow Bend Ratio  </td><td class="markdownTableBodyNone">The ratio of the controllers rotation ato apply to the rotation of the elbow. The remaining rotation is applied to the wrist's rotation.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Lock To Neck  </td><td class="markdownTableBodyNone">The Lock To Neck checkbox controls whether the Head Position Source is used to determined the model's neck position, or if the neck position is assumed to be Vector3's zero.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Rest Position  </td><td class="markdownTableBodyNone">The rest position settings specify the joint positions of each part of the mathematical model of the arm relative to the head position, before the arm model is applied.   </td></tr>
</table>
<p>The positions defined here are multiplied by -1 or 1 depending on if they are used as the left, or right arm. The positions are therefore relative to the center of the head. The table below details the Rest Position controls:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Control Name  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Elbow Rest Position  </td><td class="markdownTableBodyNone">Position of the elbow joint relative to the head before the arm model is applied.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Wrist Rest Position  </td><td class="markdownTableBodyNone">Position of the wrist joint relative to the head before the arm model is applied.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Controller Rest Position  </td><td class="markdownTableBodyNone">Position of the controller joint relative to the head before the arm model is applied.   </td></tr>
</table>
<h2>Swing Arm Model</h2>
<p>The swing arm model has the same base settings as the <a href="../../#Base-Arm-Model">Base Arm Model</a> but also contains some additional extra parameters to deal with swinging motion.</p>
<p>The swing arm model is intended to be used as a pose provider to a tracked pose driver in the same way as the base arm model.</p>
<p>In the swing arm model, there is a second set of rotation ratio parameters that are applied when the controller is pointing towards the player (ie: backwards).</p>
<p>the image below shows the swing arm model component:</p>
<p><img src="../../images/ArmModelImages/swingarmmodel.png" alt="Swing Model" class="inline"/></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Control Name  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Joint Shift Angle  </td><td class="markdownTableBodyNone">The joint shift angle property specifies the min/max angle where the model will lerp from using the normal rotation ratio for the joint to the shifted rotation ratio.Below the min vale, the normal rotation ratio setting will be used, above the max value, the shifted rotation ratio will be used. The Shifted rotation ratio is intended to be used when the controller is facing backwards to the normal orientation, or towards the user.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Joint Shift Exponent  </td><td class="markdownTableBodyNone">Exponent applied to the blend between the rotation ratio, and the shited rotation ratio.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Rotation Ratio  </td><td class="markdownTableBodyNone">The rotation ratio section of the swing arm model allows the user to configure how much of the controller rotation is applied to different joints in the simulation.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Shifted Rotation Ratio  </td><td class="markdownTableBodyNone">The shifted rotation ratio section of the swing arm model allows the user to configure how much of the controller rotation is applied to different joints in the simulation when the controller is backwards, or facing the user.   </td></tr>
</table>
<p>The table blelow further explains the rotation ratio Inspector Controls:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Control Name  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Shoulder Rotation Ratio  </td><td class="markdownTableBodyNone">Portion of the controller rotation applied to the shoulder joint.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Elbow Rotation Ratio  </td><td class="markdownTableBodyNone">Portion of the controller rotation applied to the elbow joint.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Wrist Rotation Ratio  </td><td class="markdownTableBodyNone">Portion of the controller rotation applied to the wrist joint.   </td></tr>
</table>
<p>The table blelow further explains the shifted rotation ratio Inspector Controls:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Control Name  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Shifted Shoulder Rotation Ratio  </td><td class="markdownTableBodyNone">Portion of the controller rotation applied to the shoulder joint when the controller is backwards.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Shifted Elbow Rotation Ratio  </td><td class="markdownTableBodyNone">Portion of the controller rotation applied to the elbow joint when the controller is backwards.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Shifted Wrist Rotation Ratio  </td><td class="markdownTableBodyNone">Portion of the controller rotation applied to the wrist joint when the controller is backwards.   </td></tr>
</table>
<h1>Transition Arm Model</h1>
<p>The transition arm model is used to transition between arm models at runtime.</p>
<p>Changing the arm model at runtime will cause the newly requested arm model to be transitioned in using the angular acceleration of the transition Pose Source to control the blend rate.</p>
<p>The image below shows the transition arm model component.</p>
<p><img src="../../images/ArmModelImages/Transitionarmmodel.png" alt="Transition Arm Model" class="inline"/></p>
<h2>Current Arm Model Component</h2>
<p>This field contains the current active arm model that will be used as the input to the tracked pose driver which is using the Transition arm model.</p>
<p>The current arm model field is used during edit mode to indicate which arm model will be applied when entering play mode. Setting the current arm model field when in play mode will directly set the current arm model being applied, but will not override any arm model transitioning that is currently occuring.</p>
<h2>Transitions</h2>
<p>The Transitions field is a list of key/arm model pairs. The <em>Queue</em> function allows the passing of an arm model, or a string. If the string matches any of the transitions listed in the Transitions list, that arm model will begin transitioning in.</p>
<h3>Key</h3>
<p>A string key which will be used to identify the arm model to transition to.</p>
<h3>Arm Model</h3>
<p>The arm model that will be transitioned into if the transition arm model is queued using a string Key value.</p>
<h2>Using the Transition Arm Model</h2>
<p>The transition Arm Model, like the other arm models, is intended to be used as a pose provider plugin attached to a tracked pose driver.</p>
<p>The transition arm model is intended to allow the user to transition between two, or more, arm models. When the application wishes to begin transitioning, the arm model that the application wishes to transition to is set via the <em>Queue</em> function.</p>
<p>The transition arm model will then transition from the currently selected arm mode, to the arm model that has been queued.</p>
<p>The transitioning between arm models is driven by the angular velocity of the transition pose source XR node. The more angular velocity expressed by this controller, the faster the transition arm model will transition towards to the queued arm model.</p>
<p>For Example:</p><ul>
<li>Application starts with the <em>current arm model</em> field referencing a simple pointing arm model</li>
<li>The user interacts with a ball, and the application scripts requests that the Transition Arm Model queue a swing arm model to allow the user to throw the ball.</li>
<li><p class="startli">The user then throws the ball, as the ball is released, the application scripts request that the transtional arm model queue the original starting pointing arm model.</p>
<p class="startli">The following image shows how the transition arm model would be configured to work with a number of arm models, and our example script found below:</p>
</li>
</ul>
<p><img src="../../images/ArmModelImages/ExampleTransitionArmModelSetup.png" alt="Example Configuration For Transition Arm Model Usage" class="inline"/></p>
<p>Here, the tracked pose driver is set to be driven by the transition arm model on this game object. The transition arm model has been configured to have a "Current" arm model that will be applied at startup. This is the same as the pointer arm model configured in the Transitions.</p>
<p>The transitions section has two elements configured. One being the Swing Arm Model for swinging behaviours, and the other is the Pointing Arm model used for simple pointing.</p>
<p>Our example monobehaviour has a reference to the transition arm model that it will control, as well as the names of the Arm Models that it will transition between.</p>
<p>The code below shows the implementation of the example transition arm model monobehaviour</p>
<div class="fragment"><div class="line">public class ExampleTransitionArmModel : MonoBehaviour</div>
<div class="line">{</div>
<div class="line">    [SerializeField]</div>
<div class="line">    public UnityEngine.XR.LegacyInputHelpers.TransitionArmModel transitionArmModel;</div>
<div class="line"> </div>
<div class="line">    [SerializeField]</div>
<div class="line">    public string swingArmModelName = &quot;SwingArmModel&quot;;</div>
<div class="line"> </div>
<div class="line">    [SerializeField]</div>
<div class="line">    public string pointerArmModelName = &quot;PointerArmModel&quot;;</div>
<div class="line"> </div>
<div class="line">    float timeToNextButtonPress = 0.0f;</div>
<div class="line">    int currentArmModel = 0;</div>
<div class="line"> </div>
<div class="line">    // Update is called once per frame</div>
<div class="line">    void Update()</div>
<div class="line">    {</div>
<div class="line">        // this uses the Right Trigger on the controller. to seed the input asset with this action, please</div>
<div class="line">        // consult the XR Input Seeding documentation</div>
<div class="line">        if (timeToNextButtonPress &lt;= 0.0f &amp;&amp; Input.GetButton(&quot;XRI_Right_TriggerButton&quot;))</div>
<div class="line">        {</div>
<div class="line">            if(currentArmModel == 0)</div>
<div class="line">            {</div>
<div class="line">                transitionArmModel.Queue(swingArmModelName);</div>
<div class="line">            }</div>
<div class="line">            else</div>
<div class="line">            {</div>
<div class="line">                transitionArmModel.Queue(pointerArmModelName);</div>
<div class="line">            }</div>
<div class="line">            // flip which arm we&#39;re using</div>
<div class="line">            currentArmModel = currentArmModel == 0 ? 1 : 0;</div>
<div class="line">            timeToNextButtonPress = 1.0f; // wait a second before allowing another arm model to be queued</div>
<div class="line">        }</div>
<div class="line">        else</div>
<div class="line">        {</div>
<div class="line">            timeToNextButtonPress -= Time.deltaTime;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The com.unity.xr.legacyinputhelpers package contains a number of useful helpers for building XR Projects. These include the Tracked Pose Driver and the Input Asset XR Bindings Seed Utility.</p>
<h1>Requirements</h1>
<p>The com.unity.xr.legacyinputhelpers package version 2.0.0 is compatible with the following versions of the <a class="el" href="../../d1/d88/namespaceUnity.html">Unity</a> Editor:</p>
<ul>
<li>2019.1 (recommended)</li>
</ul>
<h1>Installing com.unity.xr.legacyinputhelpers</h1>
<p>To install this package, follow the instructions in the <a href="https://docs.unity3d.com/Packages/com.unity.package-manager-ui@latest/index.html">Package Manager documentation</a>.</p>
<h1>Using com.unity.xr.legacyinputhelpers</h1>
<p>The com.unity.xr.legacyinputhelpers package contains a number of useful helpers for building XR Projects.</p><ul>
<li><a href="../../#Tracked-Pose-Driver">Tracked Pose Driver</a></li>
<li><a href="../../#Seeding-XR-Input-Bindings">XR Input Binding Seeder</a></li>
<li><a class="el" href="../../da/dcc/ArmModels_8md.html">Arm Models</a></li>
</ul>
<h1>Tracked Pose Driver</h1>
<p>The Tracked Pose Driver component is intended to be used to update a Game Object’s transform to match that of a Tracked Device. A Tracked Device is any input device which can generate a Pose. For Example: A VR HMD, an AR Device, or an MR Tracked Controller.</p>
<p>The following section of this document details the different settings and options available to the Tracked Pose Driver.</p>
<h2>Settings</h2>
<h3>Device &amp; Pose Source</h3>
<p>The Tracked Pose Driver is used to update a target transform using a Pose Source. The Pose Source is defined as a combination of the settings of both the Device Field, and the Pose Source Field.</p>
<p>The Device field is used to indicate which type of device that the pose source will be obtained from. This field has the following options:</p><ul>
<li>Generic XR Device <br  />
 This option is intended to represent VR HMDs and AR Device poses.</li>
<li>Generic XR Controller <br  />
 This option is intended to represent VR Controllers.</li>
<li>Generic XR Remote <br  />
 This option is intended to represent mobile based remote devices.</li>
</ul>
<p>The following image shows the options above in the actual Tracked Pose Driver component.</p>
<p><img src="../../images/deviceselection.png" alt="Tracked Pose Driver" class="inline"/></p>
<p>Once the Device field has been set, the Pose Source field will be updated with the available sources for that Device. These options are listed below.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Device  </th><th class="markdownTableHeadNone">Source  </th><th class="markdownTableHeadNone">Description  </th><th class="markdownTableHeadNone">Usage   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Generic XR Device  </td><td class="markdownTableBodyNone">Left Eye  </td><td class="markdownTableBodyNone">The pose of the Left Eye of the device.  </td><td class="markdownTableBodyNone">VR HMDs   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Right Eye  </td><td class="markdownTableBodyNone">The pose of the Right Eye of the device.  </td><td class="markdownTableBodyNone">VR HMDs   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Center Eye  </td><td class="markdownTableBodyNone">The pose of the Center Eye of the device.  </td><td class="markdownTableBodyNone">VR HMDs   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Head  </td><td class="markdownTableBodyNone">The pose of the Head of the device, if available. In most devices, the Head pose will be the same as the Center Eye.  </td><td class="markdownTableBodyNone">VR HMDs   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Color Camera  </td><td class="markdownTableBodyNone">The pose of the Color Camera on the device, if available. The Color camera is intended for use with AR devices which support camera based spatial mapping.  </td><td class="markdownTableBodyNone">AR Devices   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Generic XR Controller  </td><td class="markdownTableBodyNone">Left Controller  </td><td class="markdownTableBodyNone">The Left Controller device pose if available. This is intended to be used with 6 Degrees of Freedom style controllers commonly used with VR and MR devices.  </td><td class="markdownTableBodyNone">6 and 3 Degrees of Freedom VR Tracked Controllers   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Right Controller  </td><td class="markdownTableBodyNone">The Right Controller device pose if available. Zero if not. This is intended to be used with 6 Degrees of Freedom style controllers commonly used with VR and MR devices.  </td><td class="markdownTableBodyNone">6 and 3 Degrees of Freedom VR Tracked Controllers   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Generic XR Remote  </td><td class="markdownTableBodyNone">Device Pose  </td><td class="markdownTableBodyNone">This pose is intended to be used with 3 Degrees of Freedom style controllers commonly used with mobile VR devices. Eg: The Google Daydream Controller  </td><td class="markdownTableBodyNone">Mobile 3 Degrees of Freedom Tracked Controllers   </td></tr>
</table>
<p>In the case where a requested Source Pose is not valid, a position vector consisting of Zeros, and an Identity Quaternion will be provided. The following image shows an example of the Pose Source drop down when the “Generic XR Device” device has been selected.</p>
<p><img src="../../images/poseselection.png" alt="Tracked Pose Driver" class="inline"/></p>
<h2>Tracking Type</h2>
<p>The tracking type option of the Tracked Pose Driver allows the developer to control how the tracked pose is applied to the target transform.</p>
<p>If the Position option is chosen, the Position part of the Source Pose will be applied to the target transform.</p>
<p>If the Rotation option is chosen, the Rotation part of the Source Pose will be applied to the target transform.</p>
<p>If the Both Position and Rotation is chose, the entire Source Pose will be applied to the target transform. The following image shows the possible options.</p>
<p><img src="../../images/trackingtypeselection.png" alt="Tracked Pose Driver" class="inline"/></p>
<p>The default selection is to apply both the Rotation and the Position of the tracked object to the target transform.</p>
<h2>Update Type</h2>
<p>The update type option allows the developer to control when the Tracked Pose Driver applies updates from the tracked pose source. The two points are; Update, and Before Render. The default, and recommended, option is to apply updates to the target transform at both of these phases especially in situations where a Tracked Pose Driver is driving a camera Pose. It is critically important to have the position of the camera updated as close to rendering as possible for user comfort and latency reasons.</p>
<p>The Update option will cause the transform to be set in both Fixed Update (if happening that frame) and the start of the normal Update frame. This is to ensure that the target transform is in the correct location prior to executing any scripts during those phases. The following image shows the Update Type options</p>
<p><img src="../../images/updatetypeselection.png" alt="Tracked Pose Driver" class="inline"/></p>
<p>The following table outlines when during the frame the Target Pose will be updated:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Option  </th><th class="markdownTableHeadNone">Fixed Update  </th><th class="markdownTableHeadNone">Update  </th><th class="markdownTableHeadNone">Before Render   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Before Render Only  </td><td class="markdownTableBodyNone">No  </td><td class="markdownTableBodyNone">No  </td><td class="markdownTableBodyNone">Yes   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Update Only  </td><td class="markdownTableBodyNone">Yes  </td><td class="markdownTableBodyNone">Yes  </td><td class="markdownTableBodyNone">No   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Both Update and Before Render  </td><td class="markdownTableBodyNone">Yes  </td><td class="markdownTableBodyNone">Yes  </td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>
<h2>Use Relative Transform</h2>
<p>The “Use Relative Transform” option allows the user to control how the pose source is applied to the target transform. This option will be deprecated in the future, please do not use.</p>
<p>When the “Use Relative Transform” option is set, the Tracked Pose Driver caches the original position of the transform internally. This is then used to offset any source pose values so that they will be correct relative to the starting location of the object being controlled.</p>
<p>Alternatively if the ”Use Relative Transform” option is not set, the Tracked Pose Driver will apply the source pose value directly to the target transform. This is useful for when the target transform is part of a greater transform hierarchy. The following image shows the “Use Relative Transform” option of the Tracked Pose Driver.</p>
<p><img src="../../images/trackedposedriver.png" alt="Tracked Pose Driver" class="inline"/></p>
<p>The “Use Relative Transform” option was added to provide compatibility with the implicit camera control for VR cameras within <a class="el" href="../../d1/d88/namespaceUnity.html">Unity</a>. It is intended that this option, along with the Reference Transform for implicit cameras, will be removed in the future. It is recommended that best practices for Object Hierarchies be followed to correctly reflect tracked objects in the correct space. </p><h2>Additional Information</h2>
<ul>
<li>The Tracked Pose Driver can only track one pose at a time</li>
<li>If the device and pose combination are not valid, the resulting transform will be zero position and identity rotation.</li>
<li>It is possible to change the tracked node at runtime via script</li>
</ul>
<h3>Special Case Behaviour when attached to cameras</h3>
<ul>
<li>When attached to a camera, the implicit VR Device control of the camera transform is disabled, and the value generated by the Tracked Pose Driver is used instead <hr  />
</li>
</ul>
<h1>Seeding XR Input Bindings</h1>
<p>The Seed XR Input Bindings Tool can be used to populate the Input Asset with a set of crossplatform bindings intended for use with XR Devices.</p>
<h2>Using the XR Input Bindings Seeder</h2>
<p>Loading the Legacy Input Helpers package will add an additional menu option under the "Assets" Top Level Menu called "Seed XR Bindings".</p>
<p><img src="../../images/assetmenu.png" alt="Asset Menu" class="inline"/></p>
<p>Clicking this menu option will seed the Input Asset with the <a class="el" href="../../d1/d88/namespaceUnity.html">Unity</a> Cross Platform Input bindings. The XR Input Bindings will not replace any bindings which are already present in the Input Asset with the same name</p>
<hr  />
 <h1>Document Revision History</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Date  </th><th class="markdownTableHeadNone">Reason   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Feb 21, 2018  </td><td class="markdownTableBodyNone">Initial edit.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Sept 13, 2018  </td><td class="markdownTableBodyNone">Update to final release version, changed name to final   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Oct 8,2018  </td><td class="markdownTableBodyNone">renamed to legacyinputhelpers   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Oct 15,2018  </td><td class="markdownTableBodyNone">Added section for seeding XR Input Bindings   </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
